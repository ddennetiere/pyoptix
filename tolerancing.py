import numpy.random as rnd
from scipy.stats import describe
from .ui_objects import display_parameter_sheet, display_progress_bar


def display_tolerance_data(beamline, oe_list=None):
    """
    Displays the parameters of every optics in beamline active chain in a editable format

    :param beamline: beamline to analyze
    :type beamline: pyoptix.Beamline
    :param oe_list: list of optical element to tolerance. If None, all OE are diplayed
    :type oe_list: list
    :return: list of ipysheet.sheet objects containing the links to the tables displayed
    :rtype: list
    """
    sheets = {}
    for oe in beamline.active_chain:
        if oe_list is None:
            print(f"properties of {oe.name}")
            params_sheet = display_parameter_sheet(oe)
            sheets[oe.name] = params_sheet
        elif oe in oe_list:
            print(f"properties of {oe.name}")
            params_sheet = display_parameter_sheet(oe)
            sheets[oe.name] = params_sheet
    return sheets


def generate_MC_beamline(beamline, distribution="gauss"):
    """
    Changes the values of every optics parameter which has non [0,0] bounds randomly using a given distribution,
    "extreme" distribution sets the value of parameter either to the min or max value of its bounds

    Note: a gauss distribution ca lead to value outside the bounds interval as the bounds are defined as 2*sigma

    Note 2: the function leaves the beamline changed.

    :param beamline: beamline to be changed
    :type beamline: pyoptix.Beamline
    :param distribution: random distribution for the new values, can be "uniform", "extreme" or "gauss"
    :type distribution: str
    :return: None
    :rtype: Nonetype
    """
    assert distribution in ["gauss", "extreme", "uniform"]
    for oe in beamline.active_chain:
        properties = oe.dump_properties(verbose=0)
        params = properties["oe_params"]
        for param_name, param in params.items():
            if param["bounds"] != [0, 0]:
                if distribution == "gauss":
                    mean = (param["bounds"][0] + param["bounds"][1])/2
                    sigma = (param["bounds"][1] - param["bounds"][0])/2
                    new_value = rnd.normal(mean, sigma)
                elif distribution == "uniform":
                    new_value = rnd.uniform(param["bounds"][0], param["bounds"][1])
                elif distribution == "extreme":
                    new_value = rnd.choice([param["bounds"][0], param["bounds"][1]])
                else:
                    raise AttributeError('distribution should be either "gauss", "extreme" or "uniform"')
                oe._set_parameter(param_name, new_value)


def apply_tolerance_data(beamline,  tolerance_data):
    """
    Takes the links to the display objects generated by display_tolerance_data and set the values of every parameter
    of every optic in beamline active chain to the values in the table objects

    :param beamline: beamline to be changed
    :type beamline: pyoptix.Beamline
    :param tolerance_data: links to the parameters of every optics in beamline active chain as ipysheet.sheet
    :type tolerance_data: list
    :return: None
    :rtype: Nonetype
    """
    for oe in beamline.active_chain:
        if oe.name in tolerance_data:
            for cell in tolerance_data[oe.name].cells:
                param_name, param_val, param_min, param_max, param_mult, param_type, param_group, param_flags = cell.value
                param = {"value": param_val, "bounds": [float(param_min), float(param_max)],
                         "multiplier": float(param_mult), "type": int(param_type), "group": int(param_group),
                         "flags": int(param_flags)}
                oe._set_parameter(param_name, param)


def sensitivity_analysis(beamline, N_stat=100, N_rays=1000, distribution="uniform", quality=lambda bl: None,
                         tolerance_data=None, compensator=None, wavelength=20e-9):
    """
    Computes and runs N_stat version of the beamline each changed randomly using either the existing parameters
    of the beamline optics either tolerance_data as described in apply_tolerance_data. each version is run with N_rays
    rays and qualifed by calling the quality function which take beamline as an argument and returns either a numerical
    value or an iterable of numerical values. The result is a statistical description of the values return by the
    quality function.

    :param beamline: beamline to be analyzed
    :type beamline: pyoptix.Beamline
    :param N_stat: number of beamlines to compute
    :type N_stat: int
    :param N_rays: number of rays to propagate for each beamline
    :type N_rays: int
    :param distribution: distribution of the varied parameters, see generate_MC_beamline
    :type distribution:  str
    :param quality: function returning numerical values to examine
    :type quality: callable
    :param tolerance_data: if supplied, sets the optical parameters to these data. See apply_tolerance_data
    :type tolerance_data: list
    :param compensator: function returning None to be called after each beamline generation to compensate changes.
        Usually an optimization function. Takes no parameter.
    :type compensator: callable
    :param wavelength: Wavelength in m at which the beamline is aligned and radiated
    :type wavelength: float
    :return: statistical analysis of the values returned by quality function
    :rtype: scipy.describe
    """
    if tolerance_data is not None:
        apply_tolerance_data(beamline, tolerance_data)
    values = []
    comp_values = []
    bar = display_progress_bar(N_stat)
    for _ in range(N_stat):
        generate_MC_beamline(beamline, distribution=distribution)
        beamline.clear_impacts(clear_source=True)
        beamline.align(wavelength)
        beamline.active_chain[0].nrays = N_rays
        beamline.generate(wavelength)
        beamline.radiate()
        values.append(quality(beamline))
        if compensator is not None:
            compensator()
            beamline.clear_impacts(clear_source=False)
            beamline.align(wavelength)
            beamline.radiate()
            comp_values.append(quality(beamline))
        bar.value += 1
    if compensator is not None:
        return describe(comp_values), describe(values)
    else:
        return describe(values)


def inverse_sensitivity_analysis(beamline, quality=lambda bl: None, N_stat=100, N_rays=1000, distribution="uniform",
                                 criterion=lambda bl: True, parameter=None, uncertainty=1e-6):
    pass